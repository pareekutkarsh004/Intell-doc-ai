{"version":3,"file":"types.d.cts","names":["InteropZodObject","Runtime","CommandInstance","Send","END","AnnotationRoot","StateDefinition","StateType","UpdateType","AnnotationUpdateType","AnyStateSchema","StateSchema","StateSchemaFieldsToStateDefinition","InteropZodToStateDefinition","ToStateDefinition","T","TInit","StateDefinitionInit","ExtractStateType","Schema","SD","S","Fallback","ExtractUpdateType","U","FallbackBase","Partial","GraphNode","Record","Context","Nodes","Promise","ConditionalEdgeRouter","Array"],"sources":["../../src/graph/types.d.ts"],"sourcesContent":["import type { InteropZodObject } from \"@langchain/core/utils/types\";\nimport type { Runtime } from \"../pregel/runnable_types.js\";\nimport type { CommandInstance, Send } from \"../constants.js\";\nimport { END } from \"../constants.js\";\nimport type { AnnotationRoot, StateDefinition, StateType, UpdateType as AnnotationUpdateType } from \"./annotation.js\";\nimport type { AnyStateSchema, StateSchema, StateSchemaFieldsToStateDefinition } from \"../state/schema.js\";\nimport type { InteropZodToStateDefinition } from \"./zod/meta.js\";\nexport { END };\n/**\n * Convert any supported schema type to a StateDefinition.\n *\n * @internal\n */\nexport type ToStateDefinition<T> = T extends StateSchema<infer TInit> ? StateSchemaFieldsToStateDefinition<TInit> : T extends InteropZodObject ? InteropZodToStateDefinition<T> : T extends StateDefinition ? T : never;\n/**\n * Type for schema types that can be used to initialize state.\n *\n * @internal\n */\nexport type StateDefinitionInit = StateDefinition | InteropZodObject | AnyStateSchema;\n/**\n * Extract the State type from any supported schema type.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract state from\n * @template Fallback - Type to return if schema doesn't match (default: never)\n */\nexport type ExtractStateType<Schema, Fallback = Schema> = Schema extends AnnotationRoot<infer SD> ? StateType<SD> : StateType<ToStateDefinition<Schema>> extends infer S ? [S] extends [never] ? Fallback : S : Fallback;\n/**\n * Extract the Update type from any supported schema type.\n *\n * The Update type represents what a node can return to update the state.\n * All fields are optional since nodes only need to return the fields they modify.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract update type from\n * @template FallbackBase - Base type for fallback (will be partialized), defaults to Schema\n */\nexport type ExtractUpdateType<Schema, FallbackBase = Schema> = Schema extends AnnotationRoot<infer SD> ? AnnotationUpdateType<SD> : AnnotationUpdateType<ToStateDefinition<Schema>> extends infer U ? [U] extends [never] ? Partial<FallbackBase> : U : Partial<FallbackBase>;\n/**\n * Strongly-typed utility for authoring graph nodes outside of the StateGraph builder,\n * supporting inference for both state (from Schema) and runtime context (from ContextType).\n *\n * This type enables you to define graph node functions with full type safetyâ€”both\n * for the evolving state and for additional context that may be passed in at runtime.\n * Typing the context parameter allows for better code organization and precise editor support.\n *\n * Works with StateSchema, AnnotationRoot, and Zod object schemas for state, and\n * with a user-defined object shape for context.\n *\n * @template Schema - The state schema type (StateSchema, AnnotationRoot, or InteropZodObject)\n * @template Context - The type of the runtime context injected into this node (default: Record<string, unknown>)\n * @template Nodes - An optional union of valid node names for Command.goto, used for type-safe routing (default: string)\n *\n * @example\n * ```typescript\n * import { StateSchema, GraphNode } from \"@langchain/langgraph\";\n * import { z } from \"zod/v4\";\n *\n * const AgentState = new StateSchema({\n *   messages: MessagesValue,\n *   step: z.number().default(0),\n * });\n *\n * // Context shape for custom node logic (optional)\n * type MyContext = { userId: string };\n *\n * // Node receiving state and context\n * const processNode: GraphNode<typeof AgentState, MyContext> = (state, runtime) => {\n *   const { userId } = runtime; // type-safe context access\n *   return { step: state.step + 1 };\n * };\n *\n * // Node with type-safe graph routing\n * const routerNode: GraphNode<typeof AgentState, MyContext, \"agent\" | \"tool\"> = (state, runtime) => {\n *   if (state.needsTool) {\n *     return new Command({ goto: \"tool\", update: { step: state.step + 1 } });\n *   }\n *   return new Command({ goto: \"agent\" });\n * };\n *\n * // Use in graph\n * const graph = new StateGraph(AgentState)\n *   .addNode(\"process\", processNode)\n *   .addNode(\"router\", routerNode)\n *   .compile();\n * ```\n */\nexport type GraphNode<Schema, Context = Record<string, unknown>, Nodes extends string = string> = (state: ExtractStateType<Schema>, runtime: Runtime<Context>) => ExtractUpdateType<Schema> | CommandInstance<unknown, ExtractUpdateType<Schema>, Nodes> | Promise<ExtractUpdateType<Schema> | CommandInstance<unknown, ExtractUpdateType<Schema>, Nodes>>;\n/**\n * Type for conditional edge routing functions.\n *\n * Use this to type functions passed to `addConditionalEdges` for\n * full type safety on state, runtime context, and return values.\n *\n * @template Schema - The state schema type\n * @template Context - The runtime context type available to node logic\n * @template Nodes - Union of valid node names that can be routed to\n *\n * @example\n * ```typescript\n * type MyContext = { userId: string };\n * const router: ConditionalEdgeRouter<typeof AgentState, MyContext, \"agent\" | \"tool\"> =\n *   (state, runtime) => {\n *     // Access runtime context as type-safe: runtime.userId\n *     if (state.done) return END;\n *     return state.needsTool ? \"tool\" : \"agent\";\n *   };\n *\n * graph.addConditionalEdges(\"router\", router, [\"agent\", \"tool\"]);\n * ```\n */\nexport type ConditionalEdgeRouter<Schema, Context = Record<string, unknown>, Nodes extends string = string> = (state: ExtractStateType<Schema>, runtime: Runtime<Context>) => Nodes | typeof END | Send<Nodes, ExtractStateType<Schema>> | Array<Nodes | Send<Nodes, ExtractStateType<Schema>>>;\n"],"mappings":";;;;;;;;;AAaA;;;;;AAAwEY,KAA5DE,iBAA4DF,CAAAA,CAAAA,CAAAA,GAArCG,CAAqCH,SAA3BD,WAA2BC,CAAAA,KAAAA,MAAAA,CAAAA,GAAAA,kCAAAA,CAAmCI,KAAnCJ,CAAAA,GAA4CG,CAA5CH,SAAsDZ,gBAAtDY,GAAyEC,2BAAzED,CAAqGG,CAArGH,CAAAA,GAA0GG,CAA1GH,SAAoHN,eAApHM,GAAsIG,CAAtIH,GAAAA,KAAAA;;;;;;AAAoHN,KAMhLW,mBAAAA,GAAsBX,eAN0JA,GAMxIN,gBANwIM,GAMrHI,cANqHJ;;;AAM5L;;;;;;AAaA;;;;AAAyED,KAA7Da,gBAA6Db,CAAAA,MAAAA,EAAAA,WAAzBc,MAAyBd,CAAAA,GAAfc,MAAed,SAAAA,cAAAA,CAAAA,KAAAA,GAAAA,CAAAA,GAA2BE,SAA3BF,CAAqCe,EAArCf,CAAAA,GAA2CE,SAA3CF,CAAqDS,iBAArDT,CAAuEc,MAAvEd,CAAAA,CAAAA,SAAAA,KAAAA,EAAAA,GAAAA,CAAmGgB,CAAnGhB,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,GAAwHiB,QAAxHjB,GAAmIgB,CAAnIhB,GAAuIiB,QAAvIjB;;;;;;;;;;;AAgBzE;;;;;AAA8He,KAAlHG,iBAAkHH,CAAAA,MAAAA,EAAAA,eAAzED,MAAyEC,CAAAA,GAA/DD,MAA+DC,SAAhDf,cAAgDe,CAAAA,KAAAA,GAAAA,CAAAA,GAArBX,UAAqBW,CAAAA,EAAAA,CAAAA,GAAMX,UAANW,CAA2BN,iBAA3BM,CAA6CD,MAA7CC,CAAAA,CAAAA,SAAAA,KAAAA,EAAAA,GAAAA,CAAyEI,CAAzEJ,CAAAA,SAAAA,CAAAA,KAAAA,CAAAA,GAA8FM,OAA9FN,CAAsGK,YAAtGL,CAAAA,GAAsHI,CAAtHJ,GAA0HM,OAA1HN,CAAkIK,YAAlIL,CAAAA;;;;;;;;;;;;AAkD9H;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;AAAyPjB,KAxB7OwB,SAwB6OxB,CAAAA,MAAAA,EAAAA,UAxBjNyB,MAwBiNzB,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EAAAA,cAAAA,MAAAA,GAAAA,MAAAA,CAAAA,GAAAA,CAAAA,KAAAA,EAxB/Ie,gBAwB+If,CAxB9HgB,MAwB8HhB,CAAAA,EAAAA,OAAAA,EAxB5GF,OAwB4GE,CAxBpG0B,OAwBoG1B,CAAAA,EAAAA,GAxBvFoB,iBAwBuFpB,CAxBrEgB,MAwBqEhB,CAAAA,GAxB3DD,eAwB2DC,CAAAA,OAAAA,EAxBlCoB,iBAwBkCpB,CAxBhBgB,MAwBgBhB,CAAAA,EAxBP2B,KAwBO3B,CAAAA,GAxBE4B,OAwBF5B,CAxBUoB,iBAwBVpB,CAxB4BgB,MAwB5BhB,CAAAA,GAxBsCD,eAwBtCC,CAAAA,OAAAA,EAxB+DoB,iBAwB/DpB,CAxBiFgB,MAwBjFhB,CAAAA,EAxB0F2B,KAwB1F3B,CAAAA,CAAAA;;;;;;;;;;;;;;;;;;;;;;;;KAA7O6B,wCAAwCJ,kEAAkEV,iBAAiBC,kBAAkBlB,QAAQ4B,aAAaC,eAAe1B,MAAMD,KAAK2B,OAAOZ,iBAAiBC,WAAWc,MAAMH,QAAQ3B,KAAK2B,OAAOZ,iBAAiBC"}