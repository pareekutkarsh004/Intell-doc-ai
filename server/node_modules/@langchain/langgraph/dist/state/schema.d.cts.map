{"version":3,"file":"schema.d.cts","names":["JSONSchema","RunnableLike","BaseChannel","SerializableSchema","ReducedValue","UntrackedValue","STATE_SCHEMA_SYMBOL","StateSchemaFieldToChannel","F","V","I","O","StateSchemaFieldsToStateDefinition","StateSchemaInit","TInit","K","StateSchemaField","Input","Output","InferStateSchemaValue","TValue","TOutput","InferStateSchemaUpdate","TInput","StateSchema","Record","T","Promise","AnyStateSchema"],"sources":["../../src/state/schema.d.ts"],"sourcesContent":["import type { JSONSchema } from \"@langchain/core/utils/json_schema\";\nimport type { RunnableLike } from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport type { SerializableSchema } from \"./types.js\";\nimport { ReducedValue } from \"./values/reduced.js\";\nimport { UntrackedValue } from \"./values/untracked.js\";\ndeclare const STATE_SCHEMA_SYMBOL: unique symbol;\n/**\n * Maps a single StateSchema field definition to its corresponding Channel type.\n *\n * This utility type inspects the type of the field and returns an appropriate\n * `BaseChannel` type, parameterized with the state \"value\" and \"input\" types according to the field's shape.\n *\n * Rules:\n * - If the field (`F`) is a `ReducedValue<V, I>`, the channel will store values of type `V`\n *   and accept input of type `I`.\n * - If the field is a `UntrackedValue<V>`, the channel will store and accept values of type `V`.\n * - If the field is a `SerializableSchema<I, O>`, the channel will store values of type `O`\n *   (the schema's output/validated value) and accept input of type `I`.\n * - For all other types, a generic `BaseChannel<unknown, unknown>` is used as fallback.\n *\n * @template F - The StateSchema field type to map to a Channel type.\n *\n * @example\n * ```typescript\n * type MyField = ReducedValue<number, string>;\n * type ChannelType = StateSchemaFieldToChannel<MyField>;\n * // ChannelType is BaseChannel<number, string>\n * ```\n */\nexport type StateSchemaFieldToChannel<F> = F extends ReducedValue<infer V, infer I> ? BaseChannel<V, I> : F extends UntrackedValue<infer V> ? BaseChannel<V, V> : F extends SerializableSchema<infer I, infer O> ? BaseChannel<O, I> : BaseChannel<unknown, unknown>;\n/**\n * Converts a StateSchema \"init\" object (field map) into a strongly-typed\n * State Definition object, where each key is mapped to its channel type.\n *\n * This utility type is used internally to create the shape of the state channels for a given schema,\n * substituting each field with the result of `StateSchemaFieldToChannel`.\n *\n * If you define a state schema as:\n * ```typescript\n * const fields = {\n *   a: ReducedValue<number, string>(),\n *   b: UntrackedValue<boolean>(),\n *   c: SomeSerializableSchemaType, // SerializableSchema<in, out>\n * }\n * ```\n * then `StateSchemaFieldsToStateDefinition<typeof fields>` yields:\n * ```typescript\n * {\n *   a: BaseChannel<number, string>;\n *   b: BaseChannel<boolean, boolean>;\n *   c: BaseChannel<typeof schema's output type, typeof schema's input type>;\n * }\n * ```\n *\n * @template TInit - The mapping of field names to StateSchema field types.\n * @returns An object type mapping keys to channel types.\n *\n * @see StateSchemaFieldToChannel\n */\nexport type StateSchemaFieldsToStateDefinition<TInit extends StateSchemaInit> = {\n    [K in keyof TInit]: StateSchemaFieldToChannel<TInit[K]>;\n};\n/**\n * Valid field types for StateSchema.\n * Either a LangGraph state value type or a raw schema (e.g., Zod schema).\n */\nexport type StateSchemaField<Input = unknown, Output = Input> = ReducedValue<Input, Output> | UntrackedValue<Output> | SerializableSchema<Input, Output>;\n/**\n * Init object for StateSchema constructor.\n * Uses `any` to allow variance in generic types (e.g., ReducedValue<string, string[]>).\n */\nexport type StateSchemaInit = {\n    [key: string]: StateSchemaField<any, any>;\n};\n/**\n * Infer the State type from a StateSchemaInit.\n * This is the type of the full state object.\n *\n * - ReducedValue<Value, Input> → Value (the stored type)\n * - UntrackedValue<Value> → Value\n * - SerializableSchema<Input, Output> → Output (the validated type)\n */\nexport type InferStateSchemaValue<TInit extends StateSchemaInit> = {\n    [K in keyof TInit]: TInit[K] extends {\n        ValueType: infer TValue;\n    } ? TValue : TInit[K] extends UntrackedValue<infer TValue> ? TValue : TInit[K] extends SerializableSchema<unknown, infer TOutput> ? TOutput : never;\n};\n/**\n * Infer the Update type from a StateSchemaInit.\n * This is the type for partial updates to state.\n *\n * - ReducedValue<Value, Input> → Input (the reducer input type)\n * - UntrackedValue<Value> → Value\n * - SerializableSchema<Input, Output> → Input (what you provide)\n */\nexport type InferStateSchemaUpdate<TInit extends StateSchemaInit> = {\n    [K in keyof TInit]?: TInit[K] extends {\n        InputType: infer TInput;\n    } ? TInput : TInit[K] extends UntrackedValue<infer TValue> ? TValue : TInit[K] extends SerializableSchema<infer TInput, unknown> ? TInput : never;\n};\n/**\n * StateSchema provides a unified API for defining LangGraph state schemas.\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import { StateSchema, ReducedValue, MessagesValue } from \"@langchain/langgraph\";\n *\n * const AgentState = new StateSchema({\n *   // Prebuilt messages value\n *   messages: MessagesValue,\n *   // Basic LastValue channel from any standard schema\n *   currentStep: z.string(),\n *   // LastValue with native default\n *   count: z.number().default(0),\n *   // ReducedValue for fields needing reducers\n *   history: new ReducedValue(\n *     z.array(z.string()).default(() => []),\n *     {\n *       inputSchema: z.string(),\n *       reducer: (current, next) => [...current, next],\n *     }\n *   ),\n * });\n *\n * // Extract types\n * type State = typeof AgentState.State;\n * type Update = typeof AgentState.Update;\n *\n * // Use in StateGraph\n * const graph = new StateGraph(AgentState);\n * ```\n */\nexport declare class StateSchema<TInit extends StateSchemaInit> {\n    readonly init: TInit;\n    /**\n     * Symbol for runtime identification.\n     * @internal Used by isInstance for runtime type checking\n     */\n    private readonly [STATE_SCHEMA_SYMBOL];\n    /**\n     * Type declaration for the full state type.\n     * Use: `typeof myState.State`\n     */\n    State: InferStateSchemaValue<TInit>;\n    /**\n     * Type declaration for the update type.\n     * Use: `typeof myState.Update`\n     */\n    Update: InferStateSchemaUpdate<TInit>;\n    /**\n     * Type declaration for node functions.\n     * Use: `typeof myState.Node` to type node functions outside the graph builder.\n     *\n     * @example\n     * ```typescript\n     * const AgentState = new StateSchema({\n     *   count: z.number().default(0),\n     * });\n     *\n     * const myNode: typeof AgentState.Node = (state) => {\n     *   return { count: state.count + 1 };\n     * };\n     * ```\n     */\n    Node: RunnableLike<InferStateSchemaValue<TInit>, InferStateSchemaUpdate<TInit>>;\n    constructor(init: TInit);\n    /**\n     * Get the channel definitions for use with StateGraph.\n     * This converts the StateSchema fields into BaseChannel instances.\n     */\n    getChannels(): Record<string, BaseChannel>;\n    /**\n     * Get the JSON schema for the full state type.\n     * Used by Studio and API for schema introspection.\n     */\n    getJsonSchema(): JSONSchema;\n    /**\n     * Get the JSON schema for the update/input type.\n     * All fields are optional in updates.\n     */\n    getInputJsonSchema(): JSONSchema;\n    /**\n     * Get the list of channel keys (excluding managed values).\n     */\n    getChannelKeys(): string[];\n    /**\n     * Get all keys (channels + managed values).\n     */\n    getAllKeys(): string[];\n    /**\n     * Validate input data against the schema.\n     * This validates each field using its corresponding schema.\n     *\n     * @param data - The input data to validate\n     * @returns The validated data with coerced types\n     */\n    validateInput<T>(data: T): Promise<T>;\n    /**\n     * Type guard to check if a value is a StateSchema instance.\n     *\n     * @param value - The value to check.\n     * @returns True if the value is a StateSchema instance with the correct runtime tag.\n     */\n    static isInstance<TInit extends StateSchemaInit>(value: StateSchema<TInit>): value is StateSchema<TInit>;\n    static isInstance(value: unknown): value is StateSchema<any>;\n}\nexport type AnyStateSchema = StateSchema<any>;\nexport {};\n"],"mappings":";;;;;;;;cAMcM;;AADyC;AAyBvD;;;;;;;;;;;;;;;;;;;AA8BA;;AAA6DO,KA9BjDN,yBA8BiDM,CAAAA,CAAAA,CAAAA,GA9BlBL,CA8BkBK,SA9BRT,YA8BQS,CAAAA,KAAAA,EAAAA,EAAAA,KAAAA,EAAAA,CAAAA,GA9ByBX,WA8BzBW,CA9BqCJ,CA8BrCI,EA9BwCH,CA8BxCG,CAAAA,GA9B6CL,CA8B7CK,SA9BuDR,cA8BvDQ,CAAAA,KAAAA,EAAAA,CAAAA,GA9BiFX,WA8BjFW,CA9B6FJ,CA8B7FI,EA9BgGJ,CA8BhGI,CAAAA,GA9BqGL,CA8BrGK,SA9B+GV,kBA8B/GU,CAAAA,KAAAA,EAAAA,EAAAA,KAAAA,EAAAA,CAAAA,GA9BsJX,WA8BtJW,CA9BkKF,CA8BlKE,EA9BqKH,CA8BrKG,CAAAA,GA9B0KX,WA8B1KW,CAAAA,OAAAA,EAAAA,OAAAA,CAAAA;;;;;;AAO7D;;;;;;;;;;;;AAKA;AAWA;;;;;;;;;;;AAG0EC,KA1B9DF,kCA0B8DE,CAAAA,cA1BbD,eA0BaC,CAAAA,GAAAA,QAAMC,MAzBhED,KAyBgEC,GAzBxDR,yBAyBwDQ,CAzB9BD,KAyB8BC,CAzBxBA,CAyBwBA,CAAAA,CAAAA;;;AAUhF;;AAAiDF,KA7BrCG,gBA6BqCH,CAAAA,QAAAA,OAAAA,EAAAA,SA7BMI,KA6BNJ,CAAAA,GA7BeT,YA6BfS,CA7B4BI,KA6B5BJ,EA7BmCK,MA6BnCL,CAAAA,GA7B6CR,cA6B7CQ,CA7B4DK,MA6B5DL,CAAAA,GA7BsEV,kBA6BtEU,CA7ByFI,KA6BzFJ,EA7BgGK,MA6BhGL,CAAAA;;;;;AAGhCC,KA3BLD,eAAAA,GA2BKC;MAAMC,EAAAA,MAAAA,CAAAA,EA1BJC,gBA0BID,CAAAA,GAAAA,EAAAA,GAAAA,CAAAA;;;;;;;;AAmCvB;;AAA+CF,KAnDnCM,qBAmDmCN,CAAAA,cAnDCA,eAmDDA,CAAAA,GAAAA,QAC5BC,MAnDHA,KAmDGA,GAnDKA,KAmDLA,CAnDWC,CAmDXD,CAAAA,SAAAA;EAKGR,SAAAA,EAAAA,KAAAA,OAAAA;IAtDdc,MA2DyBN,GA3DhBA,KA2DgBA,CA3DVC,CA2DUD,CAAAA,SA3DCT,cA2DDS,CAAAA,KAAAA,OAAAA,CAAAA,GA3DgCM,MA2DhCN,GA3DyCA,KA2DzCA,CA3D+CC,CA2D/CD,CAAAA,SA3D0DX,kBA2D1DW,CAAAA,OAAAA,EAAAA,KAAAA,QAAAA,CAAAA,GA3DuGO,OA2DvGP,GAAAA,KAAAA;;;;;;;;;AA2BCZ,KA5EtBoB,sBA4EsBpB,CAAAA,cA5EeW,eA4EfX,CAAAA,GAAAA,QAAfuB,MA3EHX,KA2EGW,IA3EMX,KA2ENW,CA3EYV,CA2EZU,CAAAA,SAAAA;EAKEzB,SAAAA,EAAAA,KAAAA,OAAAA;IA9EbuB,MAmFkBvB,GAnFTc,KAmFSd,CAnFHe,CAmFGf,CAAAA,SAnFQK,cAmFRL,CAAAA,KAAAA,OAAAA,CAAAA,GAnFuCoB,MAmFvCpB,GAnFgDc,KAmFhDd,CAnFsDe,CAmFtDf,CAAAA,SAnFiEG,kBAmFjEH,CAAAA,KAAAA,OAAAA,EAAAA,OAAAA,CAAAA,GAnF6GuB,MAmF7GvB,GAAAA,KAAAA;;;;;;;;;;AA0B1B;;;;;;;;;;;;;;;;;;;;;;;;cA1EqBwB,0BAA0BX;iBAC5BC;;;;;oBAKGR,mBAAAA;;;;;SAKXa,sBAAsBL;;;;;UAKrBQ,uBAAuBR;;;;;;;;;;;;;;;;QAgBzBb,aAAakB,sBAAsBL,QAAQQ,uBAAuBR;oBACtDA;;;;;iBAKHW,eAAevB;;;;;mBAKbF;;;;;wBAKKA;;;;;;;;;;;;;;;;yBAgBC0B,IAAIC,QAAQD;;;;;;;kCAOHb,wBAAwBW,YAAYV,kBAAkBU,YAAYV;8CACtDU;;KAEpCI,cAAAA,GAAiBJ"}